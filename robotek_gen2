#include <Arduino.h>

/* Simple drive-forward + rotation functions for ESP32 + L298N
   USING analogWrite() INSTEAD OF ledcSetup() FOR MAX COMPATIBILITY.

   Hardware wiring:
   - Left motor:  ENA = 25 (PWM), IN1 = 26, IN2 = 27
   - Right motor: ENB = 14 (PWM), IN3 = 12, IN4 = 13
*/

void setupUltrasonic();
void setupUltrasonic();

void driveForward(float distance_cm, int speed_percent);
void rotate(float angle_deg, int speed_percent);
void stopMotors();
int speedPercentToPwm(int speedPercent);

// Ultrasonic sensor pins
const int TRIG_PIN = 4;
const int ECHO_PIN = 5;

const int ENA = 25; // left motor PWM
const int IN1 = 26;
const int IN2 = 27;

const int ENB = 14; // right motor PWM
const int IN3 = 12;
const int IN4 = 13;

// Calibration: how long to drive for 1 cm of distance
float ms_per_cm = 80.0;

// Calibration: how long to rotate 1 degree (tune for 90° turns)
float ms_per_degree = 8.4;

// Convert percent (0–100) → PWM (0–255)
int speedPercentToPwm(int speedPercent) {
  speedPercent = constrain(speedPercent, 0, 100);
  return map(speedPercent, 0, 100, 0, 255);
}

void setup() {
  Serial.begin(115200);
  setupUltrasonic();
  
  Serial.println("Drive + Rotate test starting...");

  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  stopMotors();  // Ensure stopped
}

void loop() {
  Serial.println("Rotate 90 degrees right...");
  rotate(90, 60);
  delay(1000);

  Serial.println("Rotate 90 degrees left...");
  rotate(-90, 60);
  delay(1000);

  // Stop looping
  while (true) delay(1000);
}

/* driveForward(distance_cm, speed_percent)
   Simple open-loop forward motion.
*/
void driveForward(float distance_cm, int speed_percent) {
  if (distance_cm <= 0.0 || speed_percent <= 0) return;

  unsigned long runTimeMs = (unsigned long) round(distance_cm * ms_per_cm);

  Serial.print("Driving ");
  Serial.print(distance_cm);
  Serial.print(" cm -> time: ");
  Serial.print(runTimeMs);
  Serial.println(" ms");

  // Forward direction
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);

  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);

  int pwmVal = speedPercentToPwm(speed_percent);
  analogWrite(ENA, pwmVal);
  analogWrite(ENB, pwmVal);

  unsigned long start = millis();
  while (millis() - start < runTimeMs) delay(5);

  stopMotors();
}

/* rotate(angle_deg)
   angle_deg > 0 → turn right
   angle_deg < 0 → turn left
*/
void rotate(float angle_deg, int speed_percent) {
  if (angle_deg == 0 || speed_percent <= 0) return;

  unsigned long runTimeMs =
      (unsigned long) round(abs(angle_deg) * ms_per_degree);

  Serial.print("Rotating ");
  Serial.print(angle_deg);
  Serial.print(" degrees -> ");
  Serial.print(runTimeMs);
  Serial.println(" ms");

  int pwmVal = speedPercentToPwm(speed_percent);

  if (angle_deg > 0) {
    // RIGHT TURN
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);

    digitalWrite(IN3, LOW);
    digitalWrite(IN4, HIGH);

  } else {
    // LEFT TURN
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);

    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
  }

  analogWrite(ENA, pwmVal);
  analogWrite(ENB, pwmVal);

  unsigned long start = millis();
  while (millis() - start < runTimeMs) delay(5);

  stopMotors();
}

/* stopMotors()
   Stops PWM + sets all motor pins low
*/
void stopMotors() {
  analogWrite(ENA, 0);
  analogWrite(ENB, 0);

  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}
                                             
void setupUltrasonic() {
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
}

void setupUltrasonic() {
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
}

float measureDistanceCm() {
  // Ensure trigger is low
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  // Send a 10 µs pulse to trigger
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Measure duration of echo HIGH pulse (in microseconds)
  long duration = pulseIn(ECHO_PIN, HIGH, 30000UL); 
  // 30,000 µs = 30 ms timeout ≈ max reliable distance ~5 meters

  if (duration == 0) {
    // No echo received (timeout)
    return -1.0;
  }

  // Convert time to distance:
  // Sound speed ≈ 0.0343 cm/µs, but since pulse travels to target and back:
  // distance = (duration * 0.0343) / 2
  float distance_cm = (duration * 0.0343f) / 2.0f;

  return distance_cm;
}                                             
